# 指尖上的正则表达式
### 正则表达式的定义
>正则表达式是对字符串操作的一种逻辑公式，
就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，
这个“规则字符串”用来表达对字符串的一种过滤逻辑。

>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：
1.给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；
2.可以通过正则表达式，从字符串中获取我们想要的特定部分。

>正则表达式的特点是：
1、灵活性、逻辑性和功能性非常的强；
2、可以迅速地用极简单的方式达到字符串的复杂控制；
3、对于刚接触的人来说，比较晦涩难懂。

>由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用， 小到著名编辑器EditPlus，大到Microsoft_Word、Visual_Studio等大型编辑器， 都可以使用正则表达式来处理文本内容。
### 正则表达式的语法
>正则表达式由一些普通字符和一些元字符组成，普通字符就是我们平时常见的字符串、数字之类的，当然也包括一些常见的符号，等等。 而元字符则可以理解为正则表达式引擎的保留字符，就像很多计算机语言中的保留字符一样，
他们在正则引擎中有特殊的意义，下面将介绍JavaScript中和正则相关的元字符以及API。
（不同的计算机语言，对正则引擎的实现不是完全一致的，所以，有些元字符和组合方式在JavaScript中不存在）
我们将按照下面的分类将元字符一一列出：

#### 字面量字符（Literal Characters）
``` 
字符               描述                                  描述
f                  换页符                               （u000C）
n                  换行符                               （u000A）
r                  回车                                 （u000D）
o                  NUL字符                              （u0000）
t                  制表符                               （u0009）
v                  垂直制表符                           （u000B）
Xnn                由十六进制数nn指定的拉丁字符          x0A等价于n
uxxxx              由十六进行xxxx指定的Unicode字符       u0009等价于t
cX                 控制字符（X的值必须是A-Z或a-z）       cJ等价于换行符n
```
#### 字符类（Character Classes）
``` 
字符                描述                              示例
[xyz]               匹配位于括号内的任意字符          [abc]匹配‘plain’中的a
[^xyz]              匹配不在括号之中的任意字符        [^abc]匹配‘plain’中的p
w                   等价于[a-zA-Z0-9]                w匹配‘sina’中的s
W                   等价于[^a-zA-Z0-9]               W不能匹配'sina'
s                   任何Unicode空白符                [ fnrtv]
S                   任何非空白字符                   [^ fnrtv]
d                   等价于[0-9]                      d匹配‘sina123’中的1
D                   等价于[^0-9]                     D不能匹配'sina1'中的1
[b]                 退格直接量（特例）
除换行符和其他Unicode换行符之外的任意字符，[sS]匹配任意字符a.c匹配"abc","a1c",and"a-c".
```
#### 重复（Repetition）
``` 
字符       描述                                                 
{n,m}     匹配至少n次，但不超过m次，n和m必须是非负整数，且n<=m  
{n,}      匹配至少n次
{n}       恰好匹配n次
?         匹配0次或1次，等价于{0,1}
+         匹配1次或多次，等价于{1,}
*         匹配0次或多次，等价于{0,}
```
#### 非贪婪的重复（non-greedy）
``` 
字符       描述
*？        在重复字符后加上问号，匹配模式就是非贪婪的匹配，这种模式会尽可能少的对目标字符串进行匹配
+?
??
{n}?
{n,}?
{n,m}?
```
#### 选择、分组和引用
``` 
字符       描述                                      示例
|         (选择)匹配该符号左边或右边的子表达式       (z|f)ood 匹配zood或food
(pattern) (分组)将几个项目组合成一个单元，这个        (A|B)[1-9]匹配“A5”，字
          单元可由*，+，？和|等符号使用，而且还可      母A被保存，可通过n或
          记住和这个组合匹配的字符以供后面的引用使用   RegExp的$1-$9引用该值
(?:pattern) 只组合，不记忆                            ai(?:r|R)等价于air|aiR  
n          和第n个分组第一次匹配的字符串匹配
```
#### 制定匹配位置
``` 
字符        描述                                            
^           匹配字符串的开头，在多行检索中，匹配一行的开头   
$           匹配字符串的结尾，在多行检索中，匹配一行的结尾
b           匹配一个单词边界  erb匹配'never'中的'er'，但不匹配‘verb’中的'er'
B           匹配非单词边界
(?=pattern) 正向肯定预查，在任何匹配pattern的字符串处开始匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。“Windows(?=95|98|NT|2000)”能匹配“Windows2000”的 “Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗 字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一 次匹配的搜索，而不是从包含预查的字符之后开始

(?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用.Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
```
#### 标志
- i忽略大小写
- g 执行全局匹配，即找到所有的匹配，而不是在找到第一个匹配后停止
- m 多行模式，^匹配一行的开头和字符串的开头，$匹配一行的结尾或字符串的结尾
###  JavaScript中的正则API
正则表达式的两种方法：
- 1字面量表示法：例如：var reg = /d+/i;正则表达式的主体部分，也就是示例中的d+,必须位于“//”之间，而标志位则需要跟在结束“/”的后面。
- 2实例化RegExp对象，例如：var reg = new RegExp("d+","img");第一个参数是表达式的主体，而第二个参数则是标志位，此参数可选。
>上面两种方法可以得到正则表达式的实例，通常，我们都使用第一种方式，即字面量的方式，这种方式比较直观，
第二种方式通常用来组合表达式，比如，通过用户输入的某个值，来 构造表达式，例如：var  input = 'this is a test';var reg = new RegExp("dw"+input);通过这种方式，我们可以组合成新的表达式，来达到我们的目的。在使用这种方式时，需要注意对特殊字符的转义和过滤，以免遭受恶意攻击。

RegExp对象的实例中，有三个方法和正则表达式相关，分别是test(),exec()和compile().而String对象中和正则相关的方法包括：match(),replace(),search(),split().
#### exec()
exec()方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回null。
``` 
var patt1 = new RegExp('e');  
console.log(patt1.exec("The best things in life are free"));
//[ 'e', index: 2, input: 'The best things in life are free' ]  
```
>返回的结果是一个数组[array]，该数组的第一个元素是匹配的字符串，后面的元素则是表达式分组所捕获到的值，
分组为1，则是该数组中的第一个元素，依次类推。若没有分组，该数组只包含一个元素。
该数组还有另外3个属性，input，index和lastIndex。若没有匹配成功，则返回null。 

>input属性表示目标字符串。 

>index属性表示匹配到的位置。 
 
>lastIndex属性表示上一次匹配后的位置。

另外，需要注意的是，若表达式实例中包含了全局（g）标志位，则会从lastIndex所标记的位置开始查找，而不会从字符串的开始位置进行。所以，我们可以多次调用exec()方法。
 
 #### test()
 test()方法比exec()方法简单，该方法只会返回一个Boolean值，如果匹配成功，则返回true，否则，返回false。
 
 #### match()
 需要注意的是，该方法的参数，也就是正则表达式添加了全局（g）标志位时的变化。如果没有添加全局标志位，返回结果和exec()方法的返回值一样，但不包含所有的属性。
 #### replace()
 该方法是字符串中非常强有力的方法，它接收两个参数，第一个参数为表达式，也可以直接传入字符串，该方法在内部会自动将字符串转换为正则表达式；第二个参数是想要替换成的字符串，该参数可以为一个函数，但是该函数的返回值必须为字符串。
 #### split()
 该方法可以按照传递的参数对字符串进行分割，会返回一个数组，里面包含了分割后的元素。一般用法是直接传入字符串进行分割，当然，也可以传入正则表达式，按表达式分割。
 
                     
                                                                                     






    