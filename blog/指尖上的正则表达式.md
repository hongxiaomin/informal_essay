# 指尖上的正则表达式
### 正则表达式的定义
>正则表达式是对字符串操作的一种逻辑公式，
就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，
这个“规则字符串”用来表达对字符串的一种过滤逻辑。

>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：
1.给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；
2.可以通过正则表达式，从字符串中获取我们想要的特定部分。

>正则表达式的特点是：
1、灵活性、逻辑性和功能性非常的强；
2、可以迅速地用极简单的方式达到字符串的复杂控制；
3、对于刚接触的人来说，比较晦涩难懂。

>由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用， 小到著名编辑器EditPlus，大到Microsoft_Word、Visual_Studio等大型编辑器， 都可以使用正则表达式来处理文本内容。
### 正则表达式的语法
>正则表达式由一些普通字符和一些元字符组成，普通字符就是我们平时常见的字符串、数字之类的，当然也包括一些常见的符号，等等。 而元字符则可以理解为正则表达式引擎的保留字符，就像很多计算机语言中的保留字符一样，
他们在正则引擎中有特殊的意义，下面将介绍JavaScript中和正则相关的元字符以及API。
（不同的计算机语言，对正则引擎的实现不是完全一致的，所以，有些元字符和组合方式在JavaScript中不存在）
我们将按照下面的分类将元字符一一列出：

#### 字面量字符（Literal Characters）
``` 
字符               描述                                  描述
f                  换页符                               （u000C）
n                  换行符                               （u000A）
r                  回车                                 （u000D）
o                  NUL字符                              （u0000）
t                  制表符                               （u0009）
v                  垂直制表符                           （u000B）
Xnn                由十六进制数nn指定的拉丁字符          x0A等价于n
uxxxx              由十六进行xxxx指定的Unicode字符       u0009等价于t
cX                 控制字符（X的值必须是A-Z或a-z）       cJ等价于换行符n
```
#### 字符类（Character Classes）
``` 
字符                描述                              示例
[xyz]               匹配位于括号内的任意字符          [abc]匹配‘plain’中的a
[^xyz]              匹配不在括号之中的任意字符        [^abc]匹配‘plain’中的p
w                   等价于[a-zA-Z0-9]                w匹配‘sina’中的s
W                   等价于[^a-zA-Z0-9]               W不能匹配'sina'
s                   任何Unicode空白符                [ fnrtv]
S                   任何非空白字符                   [^ fnrtv]
d                   等价于[0-9]                      d匹配‘sina123’中的1
D                   等价于[^0-9]                     D不能匹配'sina1'中的1
[b]                 退格直接量（特例）
除换行符和其他Unicode换行符之外的任意字符，[sS]匹配任意字符a.c匹配"abc","a1c",and"a-c".
```
#### 重复（Repetition）
``` 
字符       描述                                                 
{n,m}     匹配至少n次，但不超过m次，n和m必须是非负整数，且n<=m  
{n,}      匹配至少n次
{n}       恰好匹配n次
?         匹配0次或1次，等价于{0,1}
+         匹配1次或多次，等价于{1,}
*         匹配0次或多次，等价于{0,}
```
#### 非贪婪的重复（non-greedy）
``` 
字符       描述
*？        在重复字符后加上问号，匹配模式就是非贪婪的匹配，这种模式会尽可能少的对目标字符串进行匹配
+?
??
{n}?
{n,}?
{n,m}?
```
#### 选择、分组和引用
``` 
字符       描述                                      示例
|         (选择)匹配该符号左边或右边的子表达式       (z|f)ood 匹配zood或food
(pattern) (分组)将几个项目组合成一个单元，这个        (A|B)[1-9]匹配“A5”，字
          单元可由*，+，？和|等符号使用，而且还可      母A被保存，可通过n或
          记住和这个组合匹配的字符以供后面的引用使用   RegExp的$1-$9引用该值
(?:pattern) 只组合，不记忆                            ai(?:r|R)等价于air|aiR  
n          和第n个分组第一次匹配的字符串匹配
```
#### 制定匹配位置
``` 
字符        描述                                            
^           匹配字符串的开头，在多行检索中，匹配一行的开头   
$           匹配字符串的结尾，在多行检索中，匹配一行的结尾
b           匹配一个单词边界  erb匹配'never'中的'er'，但不匹配‘verb’中的'er'
B           匹配非单词边界
(?=pattern) 正向肯定预查，在任何匹配pattern的字符串处开始匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。“Windows(?=95|98|NT|2000)”能匹配“Windows2000”的 “Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗 字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一 次匹配的搜索，而不是从包含预查的字符之后开始

(?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用.Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
```
#### 标志
- i忽略大小写
- g 执行全局匹配，即找到所有的匹配，而不是在找到第一个匹配后停止
- m 多行模式，^匹配一行的开头和字符串的开头，$匹配一行的结尾或字符串的结尾





    